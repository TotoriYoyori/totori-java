<!DOCTYPE html>
<html>
  <head>
    <title>
      Arrays and Loops
    </title>

    <style>

    </style>
  </head>

  <body>




    
  <!--JavaScript starts here-->
    <script>
    /* 
      const myArray = [10, 20, 30];
      console.log(myArray);
      console.log (myArray[1]);

      myArray[0] = 99;

      [1, 'hello', true, {name: 'socks'}, [1,2,3]]
      console.log(typeof [1,2,3]);
      console.log ( Array.isArray([1,2,3]) );

      console.log(myArray.length);
      myArray.push(100);
      console.log(myArray);

      myArray.splice(0, 1);
      console.log(myArray);
    */

    /*
      let i = 1;
      while (i <= 5) {
        console.log(i);
        i ++;
      };

      for (let i = 1; i <= 5; i++) {
        console.log(i);
      };

      let randomNumber = 0;
      while (randomNumber < 0.5) {
        randomNumber = Math.random();
      };

      console.log(randomNumber);
    */

    /* const todoList = [
      'Make dinner.',
      'Wash dishes',
      'Watches YouTube'
    ];

    for (let i = 0; i < todoList.length; i++) {
      const value = todoList[i];
      console.log(value);
    };
    */ 

    const nums = [1,1,3];
    let total = 0; //This variable stores accumulation, and is used with L2A to solve accumulation patterns. An accumulator variable simply store output results from an L2A, and it can be anything (arrays, booleans, objects)

    for (let i = 0; i < nums.length; i++ ) {
      const value = nums[i];
      total += value;
    };
    console.log(total);

    const numsDoubled = []; // This variable stores updated array and is used with L2A to solve another accumulator pattern with an array as the output. 
    
    for (let i = 0; i < nums.length; i ++) {
      const value = nums[i];
      numsDoubled.push(value*2);
    };
    console.log(numsDoubled);

    const array1 = [1,2,3]
    const array2 = array1.slice(); // .slice is a method to copy all values within an array. 

    array2.push(4);
    console.log(array1);

    const [firstValue, secondValue, third] = [1,2,3]; //This destructuring is very similar to object destructuring. The order of the variables match the orders in the index of the array. (firstvalue = 1, third = 3)

      for (let i = 1; i <= 10; i++ ) {
        if (i % 3 === 0) /* % is a remainder operator that checks for if a number is divisible by a number. */{
          continue; // This skips a specific iteration. 
        };

        if (i === 8) {
          break; // This allows us to stop a loop early.
        };

        console.log(i);
      };

      let i = 1;
      while (i <= 10) {
        if (i % 3 === 0) {
          i++ // Be careful when using continue in a while-loop because you have to manually restate the increment step before continuing. Otherwise, it will also skip the increment step.
          continue;
        }
        console.log(i);
        i++;
      }
      
    function doubleArray(array) {
      const numsDoubled = []; 
    
    for (let i = 0; i < array.length; i ++) {
      const value = array[i];
      if (value === 0) {
        return numsDoubled; // Return is always a good way to stop a function if a certain condition present itself. This is an 'early return' procedure. Note that it is different from 'break' in that 'break' doesn't return a value, and only exists in loops. 
      }; 
      numsDoubled.push(value*2);
    };
      return numsDoubled;
    };

    console.log ( doubleArray([1,1,3]) );
    console.log ( doubleArray([2,2,5,0,5]) );
    </script>
  </body>
</html>